// This code is licensed under the Keep It Free License V1.
// You may find a full copy of this license at root project directory\LICENSE
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Windows.Forms;
using IOPath = System.IO.Path;
using DAZ_Installer.Utilities;

namespace DAZ_Installer.DP {
    // Notes: 
    // Directories are listed with "l -slt" with the D attribute. Files are with the A attribute.
    // Attributes: R - Read-only, H - Hidden, S - System, A - Archive (file), D - Directory
    // Note for NTFS - N - Normal is not stored on disk, is dynamically generated by OS.
    // For more info: https://jpsoft.com/help/attrswitch.htm - Attribute Switches section

    internal class DP7zArchive : DPAbstractArchive
    {
        private bool _hasEncryptedFiles = false;
        private Process _process = null;
        private string arcPassword = string.Empty;

        internal DP7zArchive(string _path,  bool innerArchive = false, string? relativePathBase = null) : base(_path, innerArchive, relativePathBase) {}

        internal override void Extract()
        {
            
        }
        #region Override Methods

        internal override void Peek()
        {
            mode = Mode.Peek;
            _process = Setup7ZProcess();
            // Check to see if we got something.
            START:
            if (GetMessage(_process, out ReadOnlySpan<char> msg))
            {
                // Check if we have an encrypted header file; meaning we cannot read
                // what is in the archive.
                if (CheckIfEncrypted(msg))
                {
                    // We do not support passwords right now.
                    // TODO: support passwords safely.
                    MessageBox.Show($"Unfortunately, {IOPath.GetFileName(Path)} is encrypted and we " +
                        "currently do not support encryption yet for 7z files.", "Unsupported encrypted archive", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                if (CheckForErrors(msg, out string errorMsg))
                {
                    // Add to error msg list.
                    DPCommon.WriteToLog(errorMsg);
                    return;
                }
                if (GetContents(msg, out string[] dirs, out string[] files))
                {
                    foreach(var dir in dirs)
                    {
                        _ = new DPFolder(dir, null);
                    }
                    foreach (var file in files)
                    {
                        var ext = GetExtension(file);
                        if (DPFile.ValidImportExtension(ext))
                        {
                            var newArchive = CreateNewArchive(file, true, RelativePath);
                            newArchive.ParentArchive = this;
                        }
                        else
                        {
                            var newFile = DPFile.CreateNewFile(file, null);
                            newFile.AssociatedArchive = this;
                        }
                    }
                }
            }
        }

        internal override void ReadContentFiles()
        {
            throw new System.NotImplementedException();
        }

        internal override void ReadMetaFiles()
        {
            throw new System.NotImplementedException();
        }

        internal override void ReleaseArchiveHandles()
        {
            
        }
        #endregion
        /// <summary>
        /// Creates a new 7z process object depending on the current mode.
        /// If the current mode is Peek, then it will tell 7z to list contents.
        /// Otherwise, it will tell 7z to extract contents.
        /// </summary>
        /// <returns>A 7z process.</returns>
        private Process Setup7ZProcess() {
            Process process = new Process();
            process.StartInfo.FileName = "7za.exe";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardInput = true;
            process.StartInfo.RedirectStandardOutput = true;

            if (mode == Mode.Peek)
                process.StartInfo.ArgumentList.Add("l");
            else
                process.StartInfo.ArgumentList.Add("e");
            process.StartInfo.ArgumentList.Add("-slt"); // Show technical information.
            if (IsInnerArchive)
                process.StartInfo.ArgumentList.Add(ExtractedPath);
            else
                process.StartInfo.ArgumentList.Add(Path);

            return process;
        }
        /// <summary>
        /// Gets the output message from 7z.
        /// </summary>
        /// <param name="process">The 7z process.</param>
        /// <param name="msg">The message from 7z.</param>
        /// <returns>Whether anything was returned from the process or not (or if any errors occurred).</returns>
        private bool GetMessage(Process process, out ReadOnlySpan<char> msg) {
            msg = string.Empty;
            try
            {
                process.Start();
                process.WaitForExit(3000);
                msg = process.StandardOutput.ReadToEnd().AsSpan();
                if (msg.Length == 0) return false;
                return true;
            } catch (Exception e)
            {
                DPCommon.WriteToLog($"An error occured while attempting to get message from 7z. REASON: {e}");
            }
            return false;
        }

        /// <summary>
        /// Parses the message and returns the directories and files of the archive.
        /// </summary>
        /// <param name="msg">The output message from 7z</param>
        /// <param name="dirs">The directories of the archive.</param>
        /// <param name="files">The files of the archive.</param>
        /// <returns>Whether getting the contents was successful (true) or not (false).</returns>
        private bool GetContents(ReadOnlySpan<char> msg, out string[] dirs, out string[] files) {
            const string fileInfoHeader = "----------\r\n";
            dirs = files = Array.Empty<string>();
            // Only spits out files, not folders.
            if (msg.Contains(fileInfoHeader))
            {
                // Then we got work to do.
                ReadOnlySpan<char> c = msg.Slice(msg.IndexOf(fileInfoHeader) + fileInfoHeader.Length);
                var contentBlocks = GetFileInfo(c);
                var fileNames = new List<string>(contentBlocks.Length);
                var dirNames = new List<string>(contentBlocks.Length);
                foreach (var content in contentBlocks)
                {
                    var _path = AnalyzeContentBlock(content, out bool isFile);
                    if (_path == string.Empty) continue;
                    if (isFile) fileNames.Add(_path);
                    else dirNames.Add(_path);
                }
                dirs = dirNames.ToArray();
                files = fileNames.ToArray();
                return true;
            }
            return false;
        }

        /// <summary>
        /// Analyzes a given content block and returns the path and whether it is a directory or not.
        /// The string returned may be an empty string (never null). Also, if for whatever reason 
        /// the attributes could not be found, isFile is false.
        /// </summary>
        /// <param name="contentBlock">The content block from 7z output.</param>
        /// <param name="isFile">Determines whether the content is a file (true) or not (false).</param>
        /// <returns>The path of the content found.</returns>
        private string AnalyzeContentBlock(string contentBlock, out bool isFile)
        {
            var lines = contentBlock.Split("\r\n");
            isFile = false;
            var _path = string.Empty;
            var attributesParsed = false;
            foreach (var line in lines)
            {
                if (attributesParsed && _path != string.Empty) break;
                if (line.StartsWith("Attributes"))
                {
                    if (line[12..].Contains("A") || !line.Contains("D")) isFile = true;
                    attributesParsed = true;
                }
                else if (line.StartsWith("Size"))
                {
                    try { TrueArchiveSize += Convert.ToUInt64(line.Split('=')[1].Trim()); }
                    catch (Exception ex) { DPCommon.WriteToLog($"Getting 7z size failed. Reason: {ex}"); }
                }
                else if (line.StartsWith("Path"))
                {
                    try { _path = line.Split('=')[1].Trim(); }
                    catch (Exception ex) { DPCommon.WriteToLog($"Failed to get 7z path. Reason: {ex}"); }
                }
                else if (line.StartsWith("Encrypted") && line.Contains('+')) _hasEncryptedFiles = true;
            }
            return _path;
        }

        private Span<string> GetFileInfo(ReadOnlySpan<char> msg) {
            Span<string> info = msg.ToString().Split("\r\n\r\n");
            info = info.Slice(0, info.Length - 1);
            return info;
        }

        private bool CheckForErrors(ReadOnlySpan<char> msg, out string errorMsg) {
            var lines = msg.ToString().Split("\r\n");
            var catchingErrors = false;
            var errorMsgs = new List<string>(2);
            foreach (var line in lines)
            {
                if (line == "Errors:") catchingErrors = true;
                if (catchingErrors)
                {
                    if (string.IsNullOrEmpty(line) || string.IsNullOrWhiteSpace(line)) break;
                    errorMsgs.Add(line);
                }
            }
            if (errorMsgs.Count == 0) errorMsg = null;
            else errorMsg = string.Join('\n', errorMsgs.ToArray());
            return catchingErrors;
        }

        private bool CheckIfEncrypted(ReadOnlySpan<char> msg) => msg.Contains("Enter password (will not be echoed): ");

        private void TellPassword(ReadOnlySpan<char> password) => password.Slice(0);

        internal bool GetMultiParts(out string[] otherArchiveNames)
        {
            // Since the inital call did not throw an error, we can assume that there are valid multipart names.
            var similarFiles = Directory.GetFiles(IOPath.GetDirectoryName(ExtractedPath),
                                         IOPath.GetFileNameWithoutExtension(ExtractedPath));
            var numList = new List<int>(similarFiles.Length);
            var possibleArchiveNames = new List<string>(similarFiles.Length);
            foreach (var file in similarFiles)
            {
                var ext = GetExtension(file); // 0001
                if (int.TryParse(ext, out int num))
                {
                    numList.Add(num);
                    possibleArchiveNames.Add(file);
                }
            }

            for (var i = numList.Count - 1; i > 0; i--)
            {
                if (numList[i] - numList[i - 1] != -1)
                {
                    otherArchiveNames = null;
                    return false;
                }
            }

            possibleArchiveNames.Sort();
            otherArchiveNames = possibleArchiveNames.ToArray();
            return true;

        }
    }
}